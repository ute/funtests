# funsamples


#'@title Class for a sample of functions
#'@description An object of class \code{funsample} can be considered both as a multivariate 
#'function of one argument and as a list of univariate functions. It is generated by function \code{funsample}.
#'@param funs a single \code{function} taking one argument, 
#'or a \code{list} of objects of class'\code{function}, that also take one argument.
#'@param arglim numeric vector, an interval the functions in \code{funlist} are defined on,
#', defaults to \code{c(0, 1)}.
#'@param ... predefined plot options, may be given as \code{\link{simplist}}s.
#'@details 
#'When called with an argument \code{x}, an object of class \code{funsample} applies
#'all functions contained in \code{fun} to \code{x}, using R-function \code{\link{sapply}}.
#'The argument limit \code{arglim} does not matter, i.e. also values \code{x} outside
#'the "allowed range" are processed.
#'
#'The return value of a \code{funsample} is a matrix. It has \code{\link{colnames}} 
#'if the list \code{funs} was named.
#'
#'Currently, only functions of one variable are allowed, i.e., for any element
#'\code{foo} of \code{funlist}, \code{foo(x)} needs to return a numeric value as
#'long as \code{x} is within \code{arglim}. The intervall \code{arglim} is necessary
#'for plotting and for coercing into an \code{\link{fdsample}} object.
#'
#'Predefining plot options may be particularly useful for plot annotation, 
#'such as i.e. \code{xlab}, \code{ylab} and \code{main}. They may be also given 
#'as a \code{plutils::\link{simplist}}. Options with same name are overriden 
#'from left to right, i.e., the last one given counts.
#'@return \code{funsample} returns an object of class \code{funsample}, that is a function of one variable
#'adorned with attributes
#'\tabular{ll}{
#'\code{funs}  \tab{a list of \code{function}s}
#'\cr\code{arglim} \tab{numeric, allowed range of function arguments}
#'\cr\code{groupsize} \tab{integer, length of \code{funs}}
#'\cr\code{options} \tab \code{\link{simplist}} of plot options, see \code{{plot.funsample}}
#'}
#'@export
#'@author Ute Hahn \email{ute@@imf.au.dk}
#'@examples
#'myfuns <- funsample(list(sin = sin, cos = cos), arglim = c(0, 2*pi)) 
#          main = "my trigo functions")
#'myfuns(c(0, pi/4, pi/2))   
#'       
funsample <- function(funs, arglim = c(0, 1), ...) #fun = mean, ...)
{
  if (is.function(funs)){
    funs <- list(funs)
  } else {
    if (!is.list(funs) || !all(sapply(funs, is.function)))
      stop ("funs should be a function or a list of functions")
  }
  if(!all(is.finite(arglim))) stop ("need finite argument range")
  options <- simplist(defaultoptions.fdsample, ..., .NULL.rm = TRUE)
  funvaltemplate <- array(0, c(length(funs),1))
  foos <- as.function(alist (x = , {
            result <- sapply(funs, function(f) (do.call(f, list(x))))
            if (is.vector(result)) result <- t(as.matrix(result))
            result
          } ))
  firstclass(foos) <- "funsample"
  attr(foos, "funs") <- funs
  attr(foos, "arglim") <- range(arglim)
  attr(foos, "groupsize") <- length(funs)
  attr(foos, "options") <- options
  foos
}

#'@rdname funsample
#'@param x an \code{R} object to be checked.
#'@description \code{is.funsample} returns \code{TRUE} if \code{x} is an object
#'of class \code{funsample}
#'@export
is.funsample <- function(x) {
  inherits(x, "funsample")
}


#'@name funsample_basic_methods
#'@aliases c.funsample
#'@title Basic methods for class funsample
#'@description Subsetting, concatenation and printing of \code{\link{funsample}}.
#'object
#'@author Ute Hahn \email{ute@@imf.au.dk}
NA

#'@rdname funsample_basic_methods
#'@method c funsample
#'@export 
#'@param ... for method \code{"c"}:\code{funsample} objects to be concatenated, 
#'otherwise further options passed to next methods
#'@param recursive ignored, for compatibility with generic function \code{\link{c}}
#'@details Method \code{"c"} concatenates the function lists contained its arguments
#'(\code{funsample} objects). The attribute \code{"arglim"} of the result is obtained
#'as intersection of the \code{arglim}s in the arguments. If this intersection is empty,
#'the method returns \code{NULL} and issues a warning. The \code{options} attribute
#'which contains plot options (in particular axis labels) is coerced from the 
#'options attributes of the \code{...} arguments. Should there be several 
#'options with the same name, priority is on the options of the first 
#'\code{funsample} in \code{...}.
#'
#'If \code{...} contains objects that are not \code{funsamples}, a \code{list} is returned.
#'TODO: also allow functions to be appended
#'
c.funsample <- function(..., recursive = FALSE)
{
  arglist <- list(...)
  if (length(arglist) < 1) return(NULL)
  allfun <- all(sapply(arglist, is.funsample))
  if (!allfun)
    return(arglist)
  if (length(arglist) < 2) return (arglist[[1]])
  # get intersection of arglims
  lims <- sapply(arglist, attr, "arglim")
  minarg <- max(lims[1, ])
  maxarg <- min(lims[2, ])
  if (maxarg <= minarg) {
    warning("argument intervals do not overlap")
    return(NULL)
  }
  # coerce options into one simplist
  lopt <- lapply(arglist, attr, "options")
  newopt <- do.call(simplist, lopt)
  
  # get list of all functions
  funlist <- unlist(lapply(myli, attr, "funs"))
  
  funsample(funlist, arglim = c(minarg, maxarg), newopt)
}